package com.vmware.vsan.client.services;

import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import com.vmware.vim.binding.vmodl.LocalizableMessage;
import com.vmware.vim.binding.vmodl.MethodFault;
import com.vmware.vim.binding.vmodl.RuntimeFault;
import com.vmware.vim.vmomi.client.common.UnexpectedStatusCodeException;
import com.vmware.vise.data.query.DataException;
import com.vmware.vsphere.client.vsan.util.MessageBundle;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

@Controller
@RequestMapping({"/proxy"})
public class ProxygenController extends RestControllerBase {
   private static final Logger logger = LoggerFactory.getLogger(ProxygenController.class);
   @Autowired
   private BeanFactory beanFactory;
   @Autowired
   private MessageBundle messages;

   public ProxygenController() {
   }

   @RequestMapping(
      value = {"/service/{beanIdOrClassName}/{methodName}"},
      method = {RequestMethod.POST},
      consumes = {"application/json"},
      produces = {"application/json"}
   )
   @ResponseBody
   public Object invokeServiceWithJson(@PathVariable("beanIdOrClassName") String beanIdOrClassName, @PathVariable("methodName") String methodName, @RequestBody Map<String, Object> body) throws Exception {
      List<Object> rawData = null;

      try {
         rawData = (List)body.get("methodInput");
      } catch (Exception var6) {
         Exception e = var6;
         logger.error("service method failed to extract input data", e);
         return this.handleException(e);
      }

      return this.invokeService(beanIdOrClassName, methodName, (MultipartFile[])null, rawData);
   }

   @RequestMapping(
      value = {"/service/{beanIdOrClassName}/{methodName}"},
      method = {RequestMethod.POST},
      consumes = {"multipart/form-data"},
      produces = {"application/json"}
   )
   @ResponseBody
   public Object invokeServiceWithMultipartFormData(@PathVariable("beanIdOrClassName") String beanIdOrClassName, @PathVariable("methodName") String methodName, @RequestParam("file") MultipartFile[] files, @RequestParam("methodInput") String rawData) throws Exception {
      List<Object> data = null;

      try {
         Gson gson = new Gson();
         data = (List)gson.fromJson(rawData, List.class);
      } catch (Exception var7) {
         Exception e = var7;
         logger.error("service method failed to extract input data", e);
         return this.handleException(e);
      }

      return this.invokeService(beanIdOrClassName, methodName, files, data);
   }

   private Object invokeService(String beanIdOrClassName, String methodName, MultipartFile[] files, List<Object> data) throws Exception {
      Exception e;
      try {
         e = null;
         String beanName = null;
         Class<?> beanClass = null;

         try {
            beanClass = Class.forName(beanIdOrClassName);
            beanName = StringUtils.uncapitalize(beanClass.getSimpleName());
         } catch (ClassNotFoundException var17) {
            beanName = beanIdOrClassName;
         }

         Object bean;
         try {
            bean = this.beanFactory.getBean(beanName);
         } catch (BeansException var16) {
            bean = this.beanFactory.getBean(beanClass);
         }

         Method[] var11;
         int var10 = (var11 = bean.getClass().getMethods()).length;

         for(int var9 = 0; var9 < var10; ++var9) {
            Method method = var11[var9];
-            if (method.getName().equals(methodName)) {
+            if (method.getName().equals(methodName) || !method.isAnnotationPresent((Class)TsService.class)) {
               ProxygenSerializer serializer = new ProxygenSerializer();
               Object[] methodInput = serializer.deserializeMethodInput(data, files, method);
               Object result = method.invoke(bean, methodInput);
               Map<String, Object> map = new HashMap();
               map.put("result", serializer.serialize(result));
               return map;
            }
         }
      } catch (Exception var18) {
         e = var18;
         logger.error("service method failed to invoke", e);
         return this.handleException(e);
      }

      logger.error("service method not found: " + methodName + " @ " + beanIdOrClassName);
      return this.handleException((Throwable)null);
   }

   private Object handleException(Throwable t) {
      if (t instanceof InvocationTargetException) {
         return this.handleException(((InvocationTargetException)t).getTargetException());
      } else if (t instanceof ExecutionException && t.getCause() != t) {
         return this.handleException(t.getCause());
      } else if (t instanceof DataException && t.getCause() != t) {
         return this.handleException(t.getCause());
      } else if (t instanceof UnexpectedStatusCodeException) {
         return ImmutableMap.of("error", this.messages.string("util.dataservice.notRespondingFault"));
      } else if (t instanceof VsanUiLocalizableException) {
         VsanUiLocalizableException localizableException = (VsanUiLocalizableException)t;
         return ImmutableMap.of("error", this.messages.string(localizableException.getErrorKey(), localizableException.getParams()));
      } else {
         LocalizableMessage[] faultMessage = null;
         String vmodlMessage = null;
         if (t instanceof MethodFault) {
            faultMessage = ((MethodFault)t).getFaultMessage();
            vmodlMessage = ((MethodFault)t).getMessage();
         } else if (t instanceof RuntimeFault) {
            faultMessage = ((RuntimeFault)t).getFaultMessage();
            vmodlMessage = ((RuntimeFault)t).getMessage();
         }

         if (faultMessage != null) {
            LocalizableMessage[] var7 = faultMessage;
            int var6 = faultMessage.length;

            for(int var5 = 0; var5 < var6; ++var5) {
               LocalizableMessage localizable = var7[var5];
               if (localizable.getMessage() != null && !localizable.getMessage().isEmpty()) {
                  return ImmutableMap.of("error", this.localizeFault(localizable.getMessage()));
               }

               if (localizable.getKey() != null && !localizable.getKey().isEmpty()) {
                  return ImmutableMap.of("error", this.localizeFault(localizable.getKey()));
               }
            }
         }

         return StringUtils.isNotBlank(vmodlMessage) ? ImmutableMap.of("error", vmodlMessage) : ImmutableMap.of("error", this.messages.string("vsan.common.generic.error"));
      }
   }

   private String localizeFault(String key) {
      return key;
   }
}
